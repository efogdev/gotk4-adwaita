// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAccentColor = coreglib.Type(C.adw_accent_color_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAccentColor, F: marshalAccentColor},
	})
}

// AccentColor describes the available system accent colors.
type AccentColor C.gint

const (
	// AccentColorBlue: use a blue color (#3584e4). This is the default value.
	AccentColorBlue AccentColor = iota
	// AccentColorTeal: use a teal color (#2190a4).
	AccentColorTeal
	// AccentColorGreen: use a green color (#3a944a).
	AccentColorGreen
	// AccentColorYellow: use a yellow color (#c88800).
	AccentColorYellow
	// AccentColorOrange: use a orange color (#ed5b00).
	AccentColorOrange
	// AccentColorRed: use a red color (#e62d42).
	AccentColorRed
	// AccentColorPink: use a pink color (#d56199).
	AccentColorPink
	// AccentColorPurple: use a purple color (#9141ac).
	AccentColorPurple
	// AccentColorSlate: use a slate color (#6f8396).
	AccentColorSlate
)

func marshalAccentColor(p uintptr) (interface{}, error) {
	return AccentColor(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccentColor.
func (a AccentColor) String() string {
	switch a {
	case AccentColorBlue:
		return "Blue"
	case AccentColorTeal:
		return "Teal"
	case AccentColorGreen:
		return "Green"
	case AccentColorYellow:
		return "Yellow"
	case AccentColorOrange:
		return "Orange"
	case AccentColorRed:
		return "Red"
	case AccentColorPink:
		return "Pink"
	case AccentColorPurple:
		return "Purple"
	case AccentColorSlate:
		return "Slate"
	default:
		return fmt.Sprintf("AccentColor(%d)", a)
	}
}

// AccentColorToRGBA converts self to a GdkRGBA representing its background
// color.
//
// The matching foreground color is white.
//
// The function takes the following parameters:
//
//   - self: accent color.
//
// The function returns the following values:
//
//   - rgba: return location for the color.
func AccentColorToRGBA(self AccentColor) *gdk.RGBA {
	var _arg1 C.AdwAccentColor // out
	var _arg2 C.GdkRGBA        // in

	_arg1 = C.AdwAccentColor(self)

	C.adw_accent_color_to_rgba(_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _rgba *gdk.RGBA // out

	_rgba = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _rgba
}

// AccentColorToStandaloneRGBA converts self to a GdkRGBA representing its
// standalone color.
//
// It will typically be darker for light background, and lighter for dark
// background, ensuring contrast.
//
// The function takes the following parameters:
//
//   - self: accent color.
//   - dark: whether to calculate standalone color for light or dark background.
//
// The function returns the following values:
//
//   - rgba: return location for the color.
func AccentColorToStandaloneRGBA(self AccentColor, dark bool) *gdk.RGBA {
	var _arg1 C.AdwAccentColor // out
	var _arg2 C.gboolean       // out
	var _arg3 C.GdkRGBA        // in

	_arg1 = C.AdwAccentColor(self)
	if dark {
		_arg2 = C.TRUE
	}

	C.adw_accent_color_to_standalone_rgba(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(dark)

	var _rgba *gdk.RGBA // out

	_rgba = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rgba
}

// RGBAToStandalone adjusts rgba to be suitable as a standalone color.
//
// It will typically be darker for light background, and lighter for dark
// background, ensuring contrast.
//
// The function takes the following parameters:
//
//   - rgba: background color.
//   - dark: whether to calculate standalone color for light or dark background.
//
// The function returns the following values:
//
//   - standaloneRgba: return location for the standalone color.
func RGBAToStandalone(rgba *gdk.RGBA, dark bool) *gdk.RGBA {
	var _arg1 *C.GdkRGBA // out
	var _arg2 C.gboolean // out
	var _arg3 C.GdkRGBA  // in

	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	if dark {
		_arg2 = C.TRUE
	}

	C.adw_rgba_to_standalone(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(rgba)
	runtime.KeepAlive(dark)

	var _standaloneRgba *gdk.RGBA // out

	_standaloneRgba = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _standaloneRgba
}

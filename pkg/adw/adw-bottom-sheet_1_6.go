// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
// extern void _gotk4_adw1_BottomSheet_ConnectCloseAttempt(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeBottomSheet = coreglib.Type(C.adw_bottom_sheet_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBottomSheet, F: marshalBottomSheet},
	})
}

// BottomSheetOverrides contains methods that are overridable.
type BottomSheetOverrides struct {
}

func defaultBottomSheetOverrides(v *BottomSheet) BottomSheetOverrides {
	return BottomSheetOverrides{}
}

// BottomSheet: bottom sheet with an optional bottom bar.
//
// <picture> <source srcset="bottom-sheet-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="bottom-sheet.png"
// alt="bottom-sheet"> </picture>
//
// AdwBottomSheet has three child widgets. bottomsheet:content is shown
// persistently. bottomsheet:sheet is displayed above it when it's open,
// and bottomsheet:bottom-bar is displayed when it's not.
//
// Bottom sheet and bottom bar are attached to the bottom edge of the widget.
// They take the full width by default, but can only take a portion of it if
// bottomsheet:full-width is set to FALSE. In this case, bottomsheet:align
// determines where along the bottom edge they are placed.
//
// AdwBottomSheet can be useful for applications such as music players, that
// want to have a persistent bottom bar that expands into a bottom sheet when
// clicked. It's meant for cases where a bottom sheet is tightly integrated into
// the UI. For more transient bottom sheets, see dialog.
//
// To open or close the bottom sheet, use the bottomsheet:open property.
//
// By default, the bottom sheet has an overlaid drag handle. It can be disabled
// by setting bottomsheet:show-drag-handle to FALSE. Note that the handle also
// controls whether the sheet can be dragged using a pointer.
//
// Bottom sheets are modal by default, meaning that the content is dimmed and
// cannot be accessed while the sheet is open. Set bottomsheet:modal to FALSE if
// this behavior is unwanted.
//
// To disable user interactions for opening or closing the bottom sheet (such as
// swipes or clicking the bottom bar or close button), set bottomsheet:can-open
// or bottomsheet:can-close to FALSE.
//
// In some cases, particularly when using a full-width bottom bar,
// it may be necessary to shift bottomsheet:content upwards. Use the
// bottomsheet:bottom-bar-height and bottomsheet:sheet-height for that.
//
// AdwBottomSheet is not adaptive, and for larger window sizes applications may
// want to replace it with another UI, such as a sidebar. This can be done using
// multilayoutview.
//
// # Sizing
//
// Unlike dialog presented as a bottom sheet, AdwBottomSheet just follows the
// content's natural size, and it's up to the applications to make sure their
// content provides one. For example, when using gtk.ScrolledWindow, make sure
// to set gtk.ScrolledWindow:propagate-natural-height to TRUE.
//
// # Header Bar Integration
//
// When placed inside an AdwBottomSheet, headerbar will not show the
// title when bottomsheet:show-drag-handle is TRUE, regardless of
// headerbar:show-title. This only applies to the default title, titles set with
// headerbar:title-widget will still be shown.
//
// AdwBottomSheet as GtkBuildable:
//
// The AdwBottomSheet implementation of the gtk.Buildable interface supports
// setting the sheet widget by specifying “sheet” as the “type” attribute of a
// <child> element, and the bottom bar by specifying “bottom-bar”. Specifying
// “content” or omitting the child type results in setting the content child.
type BottomSheet struct {
	_ [0]func() // equal guard
	gtk.Widget

	*coreglib.Object
	Swipeable
}

var (
	_ gtk.Widgetter     = (*BottomSheet)(nil)
	_ coreglib.Objector = (*BottomSheet)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BottomSheet, *BottomSheetClass, BottomSheetOverrides](
		GTypeBottomSheet,
		initBottomSheetClass,
		wrapBottomSheet,
		defaultBottomSheetOverrides,
	)
}

func initBottomSheetClass(gclass unsafe.Pointer, overrides BottomSheetOverrides, classInitFunc func(*BottomSheetClass)) {
	if classInitFunc != nil {
		class := (*BottomSheetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBottomSheet(obj *coreglib.Object) *BottomSheet {
	return &BottomSheet{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Swipeable: Swipeable{
			Widget: gtk.Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: gtk.Accessible{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
				ConstraintTarget: gtk.ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalBottomSheet(p uintptr) (interface{}, error) {
	return wrapBottomSheet(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCloseAttempt is emitted when the close button or shortcut is used
// while dialog:can-close is set to FALSE.
func (self *BottomSheet) ConnectCloseAttempt(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "close-attempt", false, unsafe.Pointer(C._gotk4_adw1_BottomSheet_ConnectCloseAttempt), f)
}

// NewBottomSheet creates a new AdwBottomSheet.
//
// The function returns the following values:
//
//   - bottomSheet: new created AdwBottomSheet.
func NewBottomSheet() *BottomSheet {
	var _cret *C.GtkWidget // in

	_cret = C.adw_bottom_sheet_new()

	var _bottomSheet *BottomSheet // out

	_bottomSheet = wrapBottomSheet(coreglib.Take(unsafe.Pointer(_cret)))

	return _bottomSheet
}

// Align gets horizontal alignment of the bottom sheet.
//
// The function returns the following values:
//
//   - gfloat: horizontal alignment.
func (self *BottomSheet) Align() float32 {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.float           // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_align(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BottomBar gets the bottom bar widget for self.
//
// The function returns the following values:
//
//   - widget (optional): bottom bar widget.
func (self *BottomSheet) BottomBar() gtk.Widgetter {
	var _arg0 *C.AdwBottomSheet // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_bottom_bar(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// BottomBarHeight gets the current bottom bar height.
//
// It can be used to shift the content upwards permanently to accommodate for
// the bottom bar.
//
// The function returns the following values:
//
//   - gint: bottom bar height.
func (self *BottomSheet) BottomBarHeight() int {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.int             // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_bottom_bar_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CanClose gets whether the bottom sheet can be closed by user.
//
// The function returns the following values:
//
//   - ok: whether the sheet can be closed by user.
func (self *BottomSheet) CanClose() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_can_close(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanOpen gets whether the bottom sheet can be opened by user.
//
// The function returns the following values:
//
//   - ok: whether the sheet can be opened by user.
func (self *BottomSheet) CanOpen() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_can_open(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Content gets the content widget for self.
//
// The function returns the following values:
//
//   - widget (optional): content widget.
func (self *BottomSheet) Content() gtk.Widgetter {
	var _arg0 *C.AdwBottomSheet // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_content(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FullWidth gets whether the bottom sheet takes the full width.
//
// The function returns the following values:
//
//   - ok: whether the sheet takes up the full width.
func (self *BottomSheet) FullWidth() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_full_width(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal gets whether the bottom sheet is modal.
//
// The function returns the following values:
//
//   - ok: whether the sheet is modal.
func (self *BottomSheet) Modal() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_modal(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Open gets whether the bottom sheet is open.
//
// The function returns the following values:
//
//   - ok: whether the sheet is open.
func (self *BottomSheet) Open() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_open(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sheet gets the bottom sheet widget for self.
//
// The function returns the following values:
//
//   - widget (optional): sheet widget.
func (self *BottomSheet) Sheet() gtk.Widgetter {
	var _arg0 *C.AdwBottomSheet // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_sheet(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SheetHeight gets the current bottom sheet height.
//
// It can be used to shift the content upwards when the bottom sheet is open.
//
// The function returns the following values:
//
//   - gint: sheet height.
func (self *BottomSheet) SheetHeight() int {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.int             // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_sheet_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ShowDragHandle gets whether to show a drag handle in the bottom sheet.
//
// The function returns the following values:
//
//   - ok: whether to show the drag handle.
func (self *BottomSheet) ShowDragHandle() bool {
	var _arg0 *C.AdwBottomSheet // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_bottom_sheet_get_show_drag_handle(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlign sets horizontal alignment of the bottom sheet.
//
// 0 means the bottom sheet is flush with the start edge, 1 means it's flush
// with the end edge. 0.5 means it's centered.
//
// Only used when bottomsheet:full-width is set to FALSE.
//
// The function takes the following parameters:
//
//   - align: new alignment.
func (self *BottomSheet) SetAlign(align float32) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.float           // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(align)

	C.adw_bottom_sheet_set_align(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(align)
}

// SetBottomBar sets the bottom bar widget for self.
//
// Shown when bottomsheet:open is FALSE. When open, morphs into the
// bottomsheet:sheet.
//
// The function takes the following parameters:
//
//   - bottomBar (optional): bottom bar widget.
func (self *BottomSheet) SetBottomBar(bottomBar gtk.Widgetter) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if bottomBar != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(bottomBar).Native()))
	}

	C.adw_bottom_sheet_set_bottom_bar(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bottomBar)
}

// SetCanClose sets whether the bottom sheet can be closed by user.
//
// It can be closed via the close button, swiping down, pressing
// <kbd>Escape</kbd> or clicking the content dimming (when modal).
//
// Bottom sheet can still be closed using bottomsheet:open.
//
// The function takes the following parameters:
//
//   - canClose: whether the sheet can be closed by user.
func (self *BottomSheet) SetCanClose(canClose bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canClose {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_can_close(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canClose)
}

// SetCanOpen sets whether the bottom sheet can be opened by user.
//
// It can be opened via clicking or swiping up from the bottom bar.
//
// Does nothing if bottomsheet:bottom-bar is not set.
//
// Bottom sheet can still be opened using bottomsheet:open.
//
// The function takes the following parameters:
//
//   - canOpen: whether the sheet can be opened by user.
func (self *BottomSheet) SetCanOpen(canOpen bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canOpen {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_can_open(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canOpen)
}

// SetContent sets the content widget for self.
//
// It's always shown, and the bottom sheet is overlaid over it.
//
// The function takes the following parameters:
//
//   - content (optional) widget.
func (self *BottomSheet) SetContent(content gtk.Widgetter) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if content != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(content).Native()))
	}

	C.adw_bottom_sheet_set_content(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(content)
}

// SetFullWidth sets whether the bottom sheet takes the full width.
//
// When full width, bottomsheet:align is ignored.
//
// The function takes the following parameters:
//
//   - fullWidth: whether the sheet takes up the full width.
func (self *BottomSheet) SetFullWidth(fullWidth bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if fullWidth {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_full_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(fullWidth)
}

// SetModal sets whether the bottom sheet is modal.
//
// When modal, bottomsheet:content will be dimmed when the bottom sheet is open,
// and clicking it will close the bottom sheet. It also cannot be focused with
// keyboard.
//
// Otherwise, the content is accessible even when the bottom sheet is open.
//
// The function takes the following parameters:
//
//   - modal: whether the sheet is modal.
func (self *BottomSheet) SetModal(modal bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_modal(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modal)
}

// SetOpen sets whether the bottom sheet is open.
//
// The function takes the following parameters:
//
//   - open: whether to open the sheet.
func (self *BottomSheet) SetOpen(open bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if open {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_open(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(open)
}

// SetSheet sets the bottom sheet widget for self.
//
// Only shown when bottomsheet:open is TRUE.
//
// The function takes the following parameters:
//
//   - sheet (optional) widget.
func (self *BottomSheet) SetSheet(sheet gtk.Widgetter) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sheet != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sheet).Native()))
	}

	C.adw_bottom_sheet_set_sheet(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sheet)
}

// SetShowDragHandle sets whether to show a drag handle in the bottom sheet.
//
// The handle will be overlaid over bottomsheet:sheet.
//
// When the handle is shown, headerbar will hide its default title, and
// toolbarview will reserve space if there are no top bars.
//
// Showing drag handle also allows to swipe the bottom sheet down (and to swipe
// the bottom bar up) with a pointer, instead of just touchscreen.
//
// The function takes the following parameters:
//
//   - showDragHandle: whether to show the drag handle.
func (self *BottomSheet) SetShowDragHandle(showDragHandle bool) {
	var _arg0 *C.AdwBottomSheet // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwBottomSheet)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if showDragHandle {
		_arg1 = C.TRUE
	}

	C.adw_bottom_sheet_set_show_drag_handle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(showDragHandle)
}
